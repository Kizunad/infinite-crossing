# 项目开发计划书 (Project Development Plan)

## 阶段一：核心引擎原型 (Core Engine Prototype)
**目标**：跑通“输入 -> 裁判裁决 -> 输出”的单回合闭环。
**形式**：纯文本界面 (CLI) 或 极简 Web 调试页。

### 任务细分
1.  **LLM 接入层**：实现与模型的基础对话接口。
2.  **Agent 编排器**：实现 `Player -> Judge <-> (World + Quest) -> Narrator` 的调用链。
3.  **状态管理器**：设计内存结构，存储 `Current World State`, `Player Stats`, `Inventory`。
4.  **裁判逻辑验证**：编写测试用例（如“尝试飞翔”），验证裁判是否能正确驳回违规操作。

## 阶段二：首个世界实装 (First World Implementation)
**目标**：让“雾隐镇”世界可玩，包含完整的死亡与结算流程。
**形式**：功能性 Web Demo。

### 任务细分
1.  **世界数据注入**：将《世界模板：雾隐镇》的设定灌入 World Agent。
2.  **坑位测试**：测试 Quest Agent 能否在不撒谎的前提下成功误导玩家。
3.  **死亡与结算系统**：实现“死亡判定” -> “世界封锁” -> “生成复盘报告”的流程。
4.  **战利品系统**：实现“结算四选一”逻辑，并生成带有副作用的战利品数据。

## 阶段三：Web 沉浸式体验 (Immersive Web UI)
**目标**：实现“侧栏 + 档案馆”的独特交互界面。
**形式**：完整 Web App。

### 任务细分
1.  **UI 框架搭建**：Next.js + Tailwind CSS。
2.  **主交互区**：流式文本显示、打字机效果、三选一按钮。
3.  **侧边栏 (Dashboard)**：
    *   显示系统给出的（可能虚假的）任务目标。
    *   显示当前的（主观）状态与库存。
4.  **档案馆 (The Archive)**：
    *   实现“死亡回放”功能。
    *   查看已解锁的（主观）世界日志。

## 阶段四：元游戏与扩展 (Metagame & Expansion)
**目标**：实现“无限穿越”与“多世界数据互通”。

### 任务细分
1.  **全局数据库**：记录玩家跨越世界的历史、获得的诅咒/能力。
2.  **新世界生成器**：不仅仅是加载模板，而是让 AI 动态生成新世界的规则与设定。
3.  **排行榜/墓碑系统**：展示其他玩家（或自己前世）的死亡记录。

---

## 阶段五：未来路线图 (Future Roadmap)

### The Atlas System (世界图谱系统)
**核心理念**：每一次游玩（无论生还或死亡）都是对世界认知的积累。
**机制描述**：
1.  **Persistent Knowledge Base**: 使用本地存储（IndexedDB）记录玩家在所有轮回中发现的地点、NPC、物品和 Lore 片段。
2.  **Completeness Tracker**: 每个世界模板都有一个“完成度”指标（例如：Mistwood Garage 15/100 Secrets Found）。
3.  **Legacy Inheritance**: 后续的轮回可以继承前世的知识。例如，如果前世发现了"生锈的钥匙"在哪里，新游戏开始时，地图上会直接标记该位置，或者 Narrator 会提示：“你依稀记得这里有个隐藏的隔间。”
4.  **Win Condition**: 当一个世界的图谱完成度达到 100%（发现所有结局和秘密），玩家获得该世界的“Mastery”状态，可能解锁特殊能力或进入下一层级的世界。

---

## 验收标准 (Acceptance Criteria)

### 原型阶段验收
- [ ] 玩家输入“我要飞”，裁判能依据物理规则（无翅膀/无魔法）拒绝，并扣除少量体力（尝试失败的代价）。
- [ ] 玩家死亡后，无法再进行任何操作，必须强制进入结算画面。

### Alpha 版验收
- [ ] 完整游玩“雾隐镇”流程，至少存在 3 种不同的死法和 1 种生还路径。
- [ ] 任务系统给出的提示确实导致了玩家误判，且复盘时能逻辑自洽。